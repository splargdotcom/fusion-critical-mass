<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fusion: Critical Mass</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: #111827;
      color: #d1d5db;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    #game-container { text-align: center; }
    #menu { display: flex; flex-direction: column; gap: 2rem; align-items: center; }
    #menu h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }
    #menu p { font-size: 0.875rem; color: #6b7280; }
    button {
      padding: 0.75rem 2rem;
      background: #1f2937;
      border: 1px solid #4b5563;
      color: #d1d5db;
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
    }
    button:hover { background: #374151; }
    #controls { font-size: 0.75rem; color: #6b7280; }
    #stats-display { display: none; }
    #game-area { display: flex; gap: 2rem; justify-content: center; align-items: flex-start; }
    #board {
      position: relative;
      border: 1px solid #374151;
      background: #030712;
    }
    .cell {
      position: absolute;
      border: 1px solid #1f2937;
    }
    #stats { min-width: 200px; text-align: left; }
    .stat { margin-bottom: 1.5rem; }
    .stat-label { font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem; }
    .stat-value { font-size: 1.25rem; }
    .stat-note { font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem; }
    #instability-bar {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    #instability-fill-container {
      flex: 1;
      height: 8px;
      background: #1f2937;
      position: relative;
      overflow: hidden;
    }
    #instability-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #6b7280;
      transition: width 0.3s;
    }
    #instability-value { font-size: 0.75rem; width: 2rem; }
    #narration {
      height: 1.5rem;
      font-size: 0.875rem;
      color: #6b7280;
      font-style: italic;
      margin: 1rem 0;
    }
    #game-controls { display: flex; gap: 1rem; justify-content: center; font-size: 0.75rem; }
    #session-info { font-size: 0.75rem; color: #4b5563; margin-top: 2rem; }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="menu">
      <div>
        <h1>Fusion: Critical Mass</h1>
        <p>Separation delays accumulation.</p>
      </div>
      <button id="start-btn">Begin</button>
      <div id="controls">
        <p>Arrow keys to move</p>
        <p>Up or Space to rotate</p>
      </div>
      <div id="session-info"></div>
    </div>
    
    <div id="stats-display">
      <div id="game-area">
        <canvas id="board" width="240" height="480"></canvas>
        <div id="stats">
          <div class="stat">
            <div class="stat-label">Duration</div>
            <div class="stat-value" id="time">0:00</div>
          </div>
          <div class="stat">
            <div class="stat-label">Total Blocks</div>
            <div class="stat-value" id="mass">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Criticality (Largest Blob)</div>
            <div id="instability-bar">
              <div id="instability-fill-container">
                <div id="instability-fill"></div>
              </div>
              <span id="instability-value">0%</span>
            </div>
            <div class="stat-note" id="mass-note"></div>
          </div>
          <div class="stat">
            <div class="stat-label">Energy Released</div>
            <div class="stat-value" id="score">0</div>
          </div>
        </div>
      </div>
      <div id="narration"></div>
      <div id="game-controls">
        <button id="quit-btn">Stop Pretending</button>
      </div>
    </div>
  </div>

  <script>
// --- AUDIO SYSTEM ---
const AudioEngine = {
  ctx: null,
  osc1: null,
  osc2: null,
  gainNode: null,
  filterNode: null,
  isInitialized: false,

  explode() {
    if (!this.ctx) return;
    const t = this.ctx.currentTime;
    
    // Create white noise buffer
    const bufferSize = this.ctx.sampleRate;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    // Filter for deep boom
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, t);
    filter.frequency.exponentialRampToValueAtTime(100, t + 1);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.5, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 1);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    noise.start();
  },

  init() {
    if (this.isInitialized) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AudioContext();
    
    this.gainNode = this.ctx.createGain();
    this.gainNode.gain.value = 0;
    this.gainNode.connect(this.ctx.destination);

    this.filterNode = this.ctx.createBiquadFilter();
    this.filterNode.type = 'lowpass';
    this.filterNode.frequency.value = 100;
    this.filterNode.connect(this.gainNode);

    this.isInitialized = true;
  },

  start() {
    if (!this.ctx) this.init();
    if (this.ctx.state === 'suspended') this.ctx.resume();

    this.osc1 = this.ctx.createOscillator();
    this.osc1.type = 'sawtooth';
    this.osc1.frequency.value = 55; 
    this.osc1.connect(this.filterNode);

    this.osc2 = this.ctx.createOscillator();
    this.osc2.type = 'sawtooth';
    this.osc2.frequency.value = 55.5; 
    this.osc2.connect(this.filterNode);

    const now = this.ctx.currentTime;
    this.osc1.start(now);
    this.osc2.start(now);
    
    this.gainNode.gain.cancelScheduledValues(now);
    this.gainNode.gain.setValueAtTime(0, now);
    this.gainNode.gain.linearRampToValueAtTime(0.15, now + 2);
  },

  update(instabilityPercent) {
    if (!this.osc1) return;
    const now = this.ctx.currentTime;
    const targetFreq = 55 + (instabilityPercent * 0.55);
    const targetFilter = 100 + (instabilityPercent * 7);

    this.osc1.frequency.setTargetAtTime(targetFreq, now, 0.5);
    this.osc2.frequency.setTargetAtTime(targetFreq + (0.5 + instabilityPercent/50), now, 0.5);
    this.filterNode.frequency.setTargetAtTime(targetFilter, now, 0.5);
  },

  stop() {
    if (!this.osc1) return;
    const now = this.ctx.currentTime;
    this.gainNode.gain.cancelScheduledValues(now);
    this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
    this.gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
    setTimeout(() => {
        if(this.osc1) {
            this.osc1.stop(); this.osc2.stop();
            this.osc1 = null; this.osc2 = null;
        }
    }, 500);
  }
};

    // --- GAME CONSTANTS ---
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const BLOCK_SIZE = 24;
    const INITIAL_SPEED = 800;
    const CRITICAL_MASS_THRESHOLD = 50; // About 12 full pieces connected triggers explosion

    const PIECES = [
      [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
      [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]],
      [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]]
    ];

    const COLORS = ['#8b9dc3', '#7b8ba3', '#6b7b93', '#5b6b83', '#4b5b73'];

    const NARRATOR_LINES = {
      firstFusion: "They are finding each other.",
      goodPlay: "Separation is temporary.",
      nearCritical: "The density is rising.",
      explosion: "Critical mass reached. Release.",
      idle: "Waiting changes nothing.",
      stabilized: "A momentary delay.",
      highMass: "It grows heavy.",
      continue: "We begin again.",
      repeat: "Inevitability confirmed.",
      inevitable: "It wants to be one."
    };

    let gameState = 'menu';
    let board = [];
    let piece = null;
    let nextPiece = null;
    let position = { x: 0, y: 0 };
    let score = 0;
    let totalSystemMass = 0;
    let largestBlobMass = 0;
    let instability = 0;
    let gameTime = 0;
    let explosionPhase = 0;
    let idleTime = 0;
    let lastMove = Date.now();
    let gameLoop = null;
    let narrationTimeout = null;

    let sessionData = {
      totalExplosions: 0,
      hasPlayedBefore: false,
      maxMassEverSeen: 0
    };

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    function initBoard() {
      // mass is now just 1 per block to represent existence
      return Array(BOARD_HEIGHT).fill(null).map(() =>
        Array(BOARD_WIDTH).fill(null).map(() => ({ filled: false, mass: 0, color: null }))
      );
    }

    function spawnPiece() {
      const p = PIECES[Math.floor(Math.random() * PIECES.length)];
      return {
        shape: p,
        color: COLORS[Math.floor(Math.random() * COLORS.length)]
      };
    }

    function showNarration(key) {
      if (sessionData.totalExplosions >= 5) return;
      const narrationEl = document.getElementById('narration');
      narrationEl.textContent = `"${NARRATOR_LINES[key]}"`;
      if (narrationTimeout) clearTimeout(narrationTimeout);
      narrationTimeout = setTimeout(() => { narrationEl.textContent = ''; }, 4000);
    }

    function startGame() {
      gameState = 'playing';
      board = initBoard();
      piece = spawnPiece();
      nextPiece = spawnPiece();
      position = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
      score = 0;
      totalSystemMass = 0;
      largestBlobMass = 0;
      instability = 0;
      gameTime = 0;
      explosionPhase = 0;
      idleTime = 0;
      lastMove = Date.now();

      sessionData.hasPlayedBefore = true;
      AudioEngine.start(); 

      document.getElementById('menu').style.display = 'none';
      document.getElementById('stats-display').style.display = 'block';
      
      updateUI();
      startGameLoop();
    }

    function checkCollision(board, piece, pos) {
      if (!piece) return true;
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const newX = pos.x + x;
            const newY = pos.y + y;
            if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
            if (newY >= 0 && board[newY][newX].filled) return true;
          }
        }
      }
      return false;
    }

    function mergePiece(board, piece, pos) {
      const newBoard = board.map(row => row.map(cell => ({...cell})));
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const boardY = pos.y + y;
            const boardX = pos.x + x;
            if (boardY >= 0) {
              // Mass is simply 1. We don't merge/eat blocks anymore.
              newBoard[boardY][boardX] = { filled: true, mass: 1, color: piece.color };
            }
          }
        }
      }
      return newBoard;
    }

    // Apply gravity: Blocks fall if space below is empty
    function applyGravity() {
      let changed = true;
      while (changed) {
        changed = false;
        for (let y = BOARD_HEIGHT - 2; y >= 0; y--) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            if (board[y][x].filled && !board[y+1][x].filled) {
              board[y+1][x] = board[y][x];
              board[y][x] = { filled: false, mass: 0 };
              changed = true;
            }
          }
        }
      }
    }

    // Scan for largest contiguous blob
    function updateInstability() {
      let maxBlob = 0;
      let totalMass = 0;
      const visited = new Set();
      const getId = (r, c) => `${r},${c}`;

      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (board[y][x].filled) {
                totalMass += 1;
            }

            if (board[y][x].filled && !visited.has(getId(y, x))) {
                // Flood fill
                let currentBlobMass = 0;
                const stack = [[y, x]];
                visited.add(getId(y, x));

                while (stack.length > 0) {
                    const [cy, cx] = stack.pop();
                    currentBlobMass += 1;

                    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    for (const [dy, dx] of dirs) {
                        const ny = cy + dy;
                        const nx = cx + dx;

                        if (ny >= 0 && ny < BOARD_HEIGHT && nx >= 0 && nx < BOARD_WIDTH) {
                            if (board[ny][nx].filled && !visited.has(getId(ny, nx))) {
                                visited.add(getId(ny, nx));
                                stack.push([ny, nx]);
                            }
                        }
                    }
                }
                if (currentBlobMass > maxBlob) maxBlob = currentBlobMass;
            }
        }
      }

      largestBlobMass = maxBlob;
      totalSystemMass = totalMass;
      
      // Instability = (Size of Blob / Limit) %
      instability = Math.min(100, Math.floor((largestBlobMass / CRITICAL_MASS_THRESHOLD) * 100));
      
      if (instability >= 80 && instability < 100 && Math.random() > 0.95) {
          showNarration('nearCritical');
      }
    }

    function triggerExplosion() {
      gameState = 'exploding';
      AudioEngine.stop();
      if (AudioEngine.explode) AudioEngine.explode();
      
      if (sessionData.totalExplosions > 0 && Math.random() > 0.5) {
        showNarration(sessionData.totalExplosions > 2 ? 'inevitable' : 'repeat');
      } else {
        showNarration('explosion');
      }
      
      explosionPhase = 1;
      render();
      
      setTimeout(() => {
        // Score is based on how much mass we accumulated before failure
        const energy = totalSystemMass * 100;
        score += energy;
        
        sessionData.totalExplosions++;
        sessionData.maxMassEverSeen = Math.max(sessionData.maxMassEverSeen, totalSystemMass);
        
        // Wipe board
        board = initBoard();
        
        totalSystemMass = 0;
        largestBlobMass = 0;
        instability = 0;
        explosionPhase = 2;
        render();
        
        if (sessionData.totalExplosions >= 1) {
          setTimeout(() => showNarration('continue'), 500);
        }
        
        setTimeout(() => {
          gameState = 'playing';
          explosionPhase = 0;
          piece = nextPiece;
          nextPiece = spawnPiece();
          position = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
          AudioEngine.start();
          render();
        }, 1500);
      }, 1000);
    }

    function moveDown() {
      if (gameState !== 'playing' || !piece) return;

      const newPos = { x: position.x, y: position.y + 1 };
      
      if (checkCollision(board, piece, newPos)) {
        // 1. Lock piece onto board
        board = mergePiece(board, piece, position);
        
        // 2. Physics: Apply gravity (blocks fall into holes)
        applyGravity();
        
        // 3. Measure: Update instability based on new blob sizes
        updateInstability();
        
        // 4. Check Criticality
        if (instability >= 100) {
          triggerExplosion();
          return;
        }
        
        // Spawn next piece
        const newNext = spawnPiece();
        piece = nextPiece;
        nextPiece = newNext;
        position = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
        
        // Immediate game over if spawn is blocked
        if (checkCollision(board, piece, position)) {
           triggerExplosion();
        }
      } else {
        position = newPos;
      }
      
      lastMove = Date.now();
      render();
    }

    function move(dx) {
      if (gameState !== 'playing' || !piece) return;
      const newPos = { x: position.x + dx, y: position.y };
      if (!checkCollision(board, piece, newPos)) {
        position = newPos;
        render();
      }
      lastMove = Date.now();
    }

    function rotate() {
      if (gameState !== 'playing' || !piece) return;
      const rotated = piece.shape[0].map((_, i) =>
        piece.shape.map(row => row[i]).reverse()
      );
      const newPiece = { ...piece, shape: rotated };
      if (!checkCollision(board, newPiece, position)) {
        piece = newPiece;
        render();
      }
      lastMove = Date.now();
    }

    function startGameLoop() {
      if (gameLoop) clearInterval(gameLoop);
      gameLoop = setInterval(() => {
        if (gameState === 'playing') {
          moveDown();
          gameTime++;
          updateUI();
          
          const now = Date.now();
          if (now - lastMove > 5000) {
            idleTime++;
            if (idleTime > 3 && Math.random() > 0.9) {
              showNarration('idle');
              idleTime = 0;
            }
          }
        }
      }, Math.max(200, INITIAL_SPEED - totalSystemMass * 2)); // Slightly faster as board fills
    }

    function render() {
      ctx.fillStyle = '#030712';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const opacity = explosionPhase === 1 ? 0.3 : 1;
      ctx.globalAlpha = opacity;
      
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const cell = board[y][x];
          if (cell.filled) {
            // Visualize "Criticality" with color intensity
            ctx.fillStyle = cell.color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#1f2937';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.8 * opacity;
      if (piece && gameState === 'playing') {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              ctx.fillStyle = piece.color;
              ctx.fillRect((position.x + x) * BLOCK_SIZE, (position.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
              ctx.strokeStyle = '#1f2937';
              ctx.strokeRect((position.x + x) * BLOCK_SIZE, (position.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
          }
        }
      }
      
      ctx.globalAlpha = 1;
      
      if (explosionPhase === 1) {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, 64, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function updateUI() {
      const m = Math.floor(gameTime / 60);
      const s = gameTime % 60;
      document.getElementById('time').textContent = `${m}:${s.toString().padStart(2, '0')}`;
      document.getElementById('mass').textContent = totalSystemMass;
      document.getElementById('mass-note').textContent = largestBlobMass > CRITICAL_MASS_THRESHOLD * 0.8 ? 'CRITICAL' : 'Stable';
      document.getElementById('instability-fill').style.width = `${instability}%`;
      document.getElementById('instability-value').textContent = `${instability}%`;
      document.getElementById('score').textContent = score;
      AudioEngine.update(instability);
    }

    function returnToMenu() {
      if (gameLoop) clearInterval(gameLoop);
      AudioEngine.stop();
      gameState = 'menu';
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('stats-display').style.display = 'none';
      document.getElementById('start-btn').textContent = sessionData.hasPlayedBefore ? 'Continue' : 'Begin';
      
      if (sessionData.totalExplosions > 0) {
        document.getElementById('session-info').innerHTML = `
          <p>Previous outcomes: ${sessionData.totalExplosions}</p>
          <p>Maximum mass observed: ${sessionData.maxMassEverSeen}</p>
        `;
      }
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('quit-btn').addEventListener('click', returnToMenu);

    document.addEventListener('keydown', (e) => {
      if (gameState !== 'playing') return;
      if (e.key === 'ArrowLeft') move(-1);
      if (e.key === 'ArrowRight') move(1);
      if (e.key === 'ArrowDown') moveDown();
      if (e.key === 'ArrowUp' || e.key === ' ') {
        e.preventDefault();
        rotate();
      }
    });

    render();
  </script>
</body>
</html>